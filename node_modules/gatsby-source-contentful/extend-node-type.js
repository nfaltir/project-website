"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.setFieldsOnGraphQLNodeType = setFieldsOnGraphQLNodeType;
exports.resolveResize = exports.resolveFluid = exports.resolveFixed = exports.generateImageSource = exports.createUrl = exports.getBase64Image = void 0;

var _commonTags = require("common-tags");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _gatsbyCoreUtils = require("gatsby-core-utils");

var _graphql = require("gatsby/graphql");

var _sortBy = _interopRequireDefault(require("lodash/sortBy"));

var _path = _interopRequireDefault(require("path"));

var _url = require("url");

var _schemes = require("./schemes");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// By default store the images in `.cache` but allow the user to override
// and store the image cache away from the gatsby cache. After all, the gatsby
// cache is more likely to go stale than the images (which never go stale)
// Note that the same image might be requested multiple times in the same run
// Supported Image Formats from https://www.contentful.com/developers/docs/references/images-api/#/reference/changing-formats/image-format
const validImageFormats = new Set([`jpg`, `png`, `webp`, `gif`]);
const mimeTypeExtensions = new Map([[`image/jpeg`, `.jpg`], [`image/jpg`, `.jpg`], [`image/gif`, `.gif`], [`image/png`, `.png`], [`image/webp`, `.webp`]]);
exports.mimeTypeExtensions = mimeTypeExtensions;

const isImage = image => {
  var _image$file;

  return mimeTypeExtensions.has(image === null || image === void 0 ? void 0 : (_image$file = image.file) === null || _image$file === void 0 ? void 0 : _image$file.contentType);
}; // Promises that rejected should stay in this map. Otherwise remove promise and put their data in resolvedBase64Cache


const inFlightBase64Cache = new Map(); // This cache contains the resolved base64 fetches. This prevents async calls for promises that have resolved.
// The images are based on urls with w=20 and should be relatively small (<2kb) but it does stick around in memory

const resolvedBase64Cache = new Map(); // @see https://www.contentful.com/developers/docs/references/images-api/#/reference/resizing-&-cropping/specify-width-&-height

const CONTENTFUL_IMAGE_MAX_SIZE = 4000; // Note: this may return a Promise<body>, body (sync), or null

const getBase64Image = (imageProps, cache) => {
  if (!imageProps) {
    return null;
  } // We only support images that are delivered through Contentful's Image API


  if (imageProps.baseUrl.indexOf(`images.ctfassets.net`) === -1) {
    return null;
  } // Keep aspect ratio, image format and other transform options


  const {
    aspectRatio
  } = imageProps;
  const originalFormat = imageProps.image.file.contentType.split(`/`)[1];
  const toFormat = imageProps.options.toFormat;
  const imageOptions = { ...imageProps.options,
    toFormat,
    width: 20,
    height: Math.floor(20 * aspectRatio)
  };
  const requestUrl = createUrl(imageProps.baseUrl, imageOptions); // Prefer to return data sync if we already have it

  const alreadyFetched = resolvedBase64Cache.get(requestUrl);

  if (alreadyFetched) {
    return alreadyFetched;
  } // If already in flight for this url return the same promise as the first call


  const inFlight = inFlightBase64Cache.get(requestUrl);

  if (inFlight) {
    return inFlight;
  }

  const loadImage = async () => {
    const {
      file: {
        contentType
      }
    } = imageProps.image;
    const extension = mimeTypeExtensions.get(contentType);
    const absolutePath = await (0, _gatsbyCoreUtils.fetchRemoteFile)({
      url: requestUrl,
      cache,
      ext: extension
    });
    const base64 = (await _fsExtra.default.readFile(absolutePath)).toString(`base64`);
    return `data:image/${toFormat || originalFormat};base64,${base64}`;
  };

  const promise = loadImage();
  inFlightBase64Cache.set(requestUrl, promise);
  return promise.then(body => {
    inFlightBase64Cache.delete(requestUrl);
    resolvedBase64Cache.set(requestUrl, body);
    return body;
  });
};

exports.getBase64Image = getBase64Image;

const getBasicImageProps = (image, args) => {
  let aspectRatio;

  if (args.width && args.height) {
    aspectRatio = args.width / args.height;
  } else {
    aspectRatio = image.file.details.image.width / image.file.details.image.height;
  }

  return {
    baseUrl: image.file.url,
    contentType: image.file.contentType,
    aspectRatio,
    width: image.file.details.image.width,
    height: image.file.details.image.height
  };
};

const createUrl = (imgUrl, options = {}) => {
  // If radius is -1, we need to pass `max` to the API
  const cornerRadius = options.cornerRadius === -1 ? `max` : options.cornerRadius; // Convert to Contentful names and filter out undefined/null values.

  const urlArgs = {
    w: options.width || undefined,
    h: options.height || undefined,
    fl: options.toFormat === `jpg` && options.jpegProgressive ? `progressive` : undefined,
    q: options.quality || undefined,
    fm: options.toFormat || undefined,
    fit: options.resizingBehavior || undefined,
    f: options.cropFocus || undefined,
    bg: options.background || undefined,
    r: cornerRadius || undefined
  };
  const searchParams = new _url.URLSearchParams();

  for (const paramKey in urlArgs) {
    if (typeof urlArgs[paramKey] !== `undefined`) {
      var _urlArgs$paramKey;

      searchParams.append(paramKey, (_urlArgs$paramKey = urlArgs[paramKey]) !== null && _urlArgs$paramKey !== void 0 ? _urlArgs$paramKey : ``);
    }
  }

  return `https:${imgUrl}?${searchParams.toString()}`;
};

exports.createUrl = createUrl;

const generateImageSource = (filename, width, height, toFormat, _fit, // We use resizingBehavior instead
imageTransformOptions) => {
  const {
    jpegProgressive,
    quality,
    cropFocus,
    backgroundColor,
    resizingBehavior,
    cornerRadius
  } = imageTransformOptions; // Ensure we stay within Contentfuls Image API limits

  if (width > CONTENTFUL_IMAGE_MAX_SIZE) {
    height = Math.floor(height / width * CONTENTFUL_IMAGE_MAX_SIZE);
    width = CONTENTFUL_IMAGE_MAX_SIZE;
  }

  if (height > CONTENTFUL_IMAGE_MAX_SIZE) {
    width = Math.floor(width / height * CONTENTFUL_IMAGE_MAX_SIZE);
    height = CONTENTFUL_IMAGE_MAX_SIZE;
  }

  if (!validImageFormats.has(toFormat)) {
    console.warn(`[gatsby-source-contentful] Invalid image format "${toFormat}". Supported types are jpg, png and webp"`);
    return undefined;
  }

  const src = createUrl(filename, {
    width,
    height,
    toFormat,
    resizingBehavior,
    background: backgroundColor === null || backgroundColor === void 0 ? void 0 : backgroundColor.replace(`#`, `rgb:`),
    quality,
    jpegProgressive,
    cropFocus,
    cornerRadius
  });
  return {
    width,
    height,
    format: toFormat,
    src
  };
};

exports.generateImageSource = generateImageSource;
const fitMap = new Map([[`pad`, `contain`], [`fill`, `cover`], [`scale`, `fill`], [`crop`, `cover`], [`thumb`, `cover`]]);

const resolveFixed = (image, options) => {
  if (!isImage(image)) return null;
  const {
    baseUrl,
    width,
    aspectRatio
  } = getBasicImageProps(image, options);
  let desiredAspectRatio = aspectRatio; // If no dimension is given, set a default width

  if (options.width === undefined && options.height === undefined) {
    options.width = 400;
  } // If only a height is given, calculate the width based on the height and the aspect ratio


  if (options.height !== undefined && options.width === undefined) {
    options.width = Math.round(options.height * desiredAspectRatio);
  } // If we're cropping, calculate the specified aspect ratio.


  if (options.width !== undefined && options.height !== undefined) {
    desiredAspectRatio = options.width / options.height;
  } // If the user selected a height and width (so cropping) and fit option
  // is not set, we'll set our defaults


  if (options.width !== undefined && options.height !== undefined) {
    if (!options.resizingBehavior) {
      options.resizingBehavior = `fill`;
    }
  } // Create sizes (in width) for the image. If the width of the
  // image is 800px, the sizes would then be: 800, 1200, 1600,
  // 2400.
  //
  // This is enough sizes to provide close to the optimal image size for every
  // device size / screen resolution


  let fixedSizes = [];
  fixedSizes.push(options.width);
  fixedSizes.push(options.width * 1.5);
  fixedSizes.push(options.width * 2);
  fixedSizes.push(options.width * 3);
  fixedSizes = fixedSizes.map(Math.round); // Filter out sizes larger than the image's width and the contentful image's max size.

  const filteredSizes = fixedSizes.filter(size => {
    const calculatedHeight = Math.round(size / desiredAspectRatio);
    return size <= CONTENTFUL_IMAGE_MAX_SIZE && calculatedHeight <= CONTENTFUL_IMAGE_MAX_SIZE && size <= width;
  }); // Sort sizes for prettiness.

  const sortedSizes = (0, _sortBy.default)(filteredSizes); // Create the srcSet.

  const srcSet = sortedSizes.map((size, i) => {
    let resolution;

    switch (i) {
      case 0:
        resolution = `1x`;
        break;

      case 1:
        resolution = `1.5x`;
        break;

      case 2:
        resolution = `2x`;
        break;

      case 3:
        resolution = `3x`;
        break;

      default:
    }

    const h = Math.round(size / desiredAspectRatio);
    return `${createUrl(baseUrl, { ...options,
      width: size,
      height: h
    })} ${resolution}`;
  }).join(`,\n`);
  let pickedHeight;
  let pickedWidth;

  if (options.height) {
    pickedHeight = options.height;
    pickedWidth = options.height * desiredAspectRatio;
  } else {
    pickedHeight = options.width / desiredAspectRatio;
    pickedWidth = options.width;
  }

  return {
    aspectRatio: desiredAspectRatio,
    baseUrl,
    width: Math.round(pickedWidth),
    height: Math.round(pickedHeight),
    src: createUrl(baseUrl, { ...options,
      width: options.width
    }),
    srcSet
  };
};

exports.resolveFixed = resolveFixed;

const resolveFluid = (image, options) => {
  if (!isImage(image)) return null;
  const {
    baseUrl,
    width,
    aspectRatio
  } = getBasicImageProps(image, options);
  let desiredAspectRatio = aspectRatio; // If no dimension is given, set a default maxWidth

  if (options.maxWidth === undefined && options.maxHeight === undefined) {
    options.maxWidth = 800;
  } // If only a maxHeight is given, calculate the maxWidth based on the height and the aspect ratio


  if (options.maxHeight !== undefined && options.maxWidth === undefined) {
    options.maxWidth = Math.round(options.maxHeight * desiredAspectRatio);
  } // If we're cropping, calculate the specified aspect ratio.


  if (options.maxHeight !== undefined && options.maxWidth !== undefined) {
    desiredAspectRatio = options.maxWidth / options.maxHeight;
  } // If the users didn't set a default sizes, we'll make one.


  if (!options.sizes) {
    options.sizes = `(max-width: ${options.maxWidth}px) 100vw, ${options.maxWidth}px`;
  } // Create sizes (in width) for the image. If the max width of the container
  // for the rendered markdown file is 800px, the sizes would then be: 200,
  // 400, 800, 1200, 1600, 2400.
  //
  // This is enough sizes to provide close to the optimal image size for every
  // device size / screen resolution


  let fluidSizes = [];
  fluidSizes.push(options.maxWidth / 4);
  fluidSizes.push(options.maxWidth / 2);
  fluidSizes.push(options.maxWidth);
  fluidSizes.push(options.maxWidth * 1.5);
  fluidSizes.push(options.maxWidth * 2);
  fluidSizes.push(options.maxWidth * 3);
  fluidSizes = fluidSizes.map(Math.round); // Filter out sizes larger than the image's maxWidth and the contentful image's max size.

  const filteredSizes = fluidSizes.filter(size => {
    const calculatedHeight = Math.round(size / desiredAspectRatio);
    return size <= CONTENTFUL_IMAGE_MAX_SIZE && calculatedHeight <= CONTENTFUL_IMAGE_MAX_SIZE && size <= width;
  }); // Add the original image (if it isn't already in there) to ensure the largest image possible
  // is available for small images.

  if (!filteredSizes.includes(width) && width < CONTENTFUL_IMAGE_MAX_SIZE && Math.round(width / desiredAspectRatio) < CONTENTFUL_IMAGE_MAX_SIZE) {
    filteredSizes.push(width);
  } // Sort sizes for prettiness.


  const sortedSizes = (0, _sortBy.default)(filteredSizes); // Create the srcSet.

  const srcSet = sortedSizes.map(width => {
    const h = Math.round(width / desiredAspectRatio);
    return `${createUrl(image.file.url, { ...options,
      width,
      height: h
    })} ${Math.round(width)}w`;
  }).join(`,\n`);
  return {
    aspectRatio: desiredAspectRatio,
    baseUrl,
    src: createUrl(baseUrl, { ...options,
      width: options.maxWidth,
      height: options.maxHeight
    }),
    srcSet,
    sizes: options.sizes
  };
};

exports.resolveFluid = resolveFluid;

const resolveResize = (image, options) => {
  if (!isImage(image)) return null;
  const {
    baseUrl,
    aspectRatio
  } = getBasicImageProps(image, options); // If no dimension is given, set a default width

  if (options.width === undefined && options.height === undefined) {
    options.width = 400;
  } // If the user selected a height and width (so cropping) and fit option
  // is not set, we'll set our defaults


  if (options.width !== undefined && options.height !== undefined) {
    if (!options.resizingBehavior) {
      options.resizingBehavior = `fill`;
    }
  }

  let pickedHeight = options.height;
  let pickedWidth = options.width;

  if (pickedWidth === undefined) {
    pickedWidth = pickedHeight * aspectRatio;
  }

  if (pickedHeight === undefined) {
    pickedHeight = pickedWidth / aspectRatio;
  }

  return {
    src: createUrl(image.file.url, options),
    width: Math.round(pickedWidth),
    height: Math.round(pickedHeight),
    aspectRatio,
    baseUrl
  };
};

exports.resolveResize = resolveResize;

const fixedNodeType = ({
  name,
  getTracedSVG,
  cache
}) => {
  return {
    type: new _graphql.GraphQLObjectType({
      name: name,
      fields: {
        base64: {
          type: _graphql.GraphQLString,
          resolve: imageProps => getBase64Image(imageProps, cache)
        },
        tracedSVG: {
          type: _graphql.GraphQLString,
          resolve: getTracedSVG
        },
        aspectRatio: {
          type: _graphql.GraphQLFloat
        },
        width: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLFloat)
        },
        height: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLFloat)
        },
        src: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLString)
        },
        srcSet: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLString)
        },
        srcWebp: {
          type: _graphql.GraphQLString,

          resolve({
            image,
            options
          }) {
            var _image$file2;

            if ((image === null || image === void 0 ? void 0 : (_image$file2 = image.file) === null || _image$file2 === void 0 ? void 0 : _image$file2.contentType) === `image/webp` || options.toFormat === `webp`) {
              return null;
            }

            const fixed = resolveFixed(image, { ...options,
              toFormat: `webp`
            });
            return fixed === null || fixed === void 0 ? void 0 : fixed.src;
          }

        },
        srcSetWebp: {
          type: _graphql.GraphQLString,

          resolve({
            image,
            options
          }) {
            var _image$file3;

            if ((image === null || image === void 0 ? void 0 : (_image$file3 = image.file) === null || _image$file3 === void 0 ? void 0 : _image$file3.contentType) === `image/webp` || options.toFormat === `webp`) {
              return null;
            }

            const fixed = resolveFixed(image, { ...options,
              toFormat: `webp`
            });
            return fixed === null || fixed === void 0 ? void 0 : fixed.srcSet;
          }

        }
      }
    }),
    args: {
      width: {
        type: _graphql.GraphQLInt
      },
      height: {
        type: _graphql.GraphQLInt
      },
      quality: {
        type: _graphql.GraphQLInt,
        defaultValue: 50
      },
      toFormat: {
        type: _schemes.ImageFormatType,
        defaultValue: ``
      },
      resizingBehavior: {
        type: _schemes.ImageResizingBehavior
      },
      cropFocus: {
        type: _schemes.ImageCropFocusType,
        defaultValue: null
      },
      cornerRadius: {
        type: _graphql.GraphQLInt,
        defaultValue: 0,
        description: (0, _commonTags.stripIndent)`
         Desired corner radius in pixels. Results in an image with rounded corners.
         Pass \`-1\` for a full circle/ellipse.`
      },
      background: {
        type: _graphql.GraphQLString,
        defaultValue: null
      }
    },

    resolve(image, options, context) {
      const node = resolveFixed(image, options);
      if (!node) return null;
      return { ...node,
        image,
        options,
        context
      };
    }

  };
};

const fluidNodeType = ({
  name,
  getTracedSVG,
  cache
}) => {
  return {
    type: new _graphql.GraphQLObjectType({
      name: name,
      fields: {
        base64: {
          type: _graphql.GraphQLString,
          resolve: imageProps => getBase64Image(imageProps, cache)
        },
        tracedSVG: {
          type: _graphql.GraphQLString,
          resolve: getTracedSVG
        },
        aspectRatio: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLFloat)
        },
        src: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLString)
        },
        srcSet: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLString)
        },
        srcWebp: {
          type: _graphql.GraphQLString,

          resolve({
            image,
            options
          }) {
            var _image$file4;

            if ((image === null || image === void 0 ? void 0 : (_image$file4 = image.file) === null || _image$file4 === void 0 ? void 0 : _image$file4.contentType) === `image/webp` || options.toFormat === `webp`) {
              return null;
            }

            const fluid = resolveFluid(image, { ...options,
              toFormat: `webp`
            });
            return fluid === null || fluid === void 0 ? void 0 : fluid.src;
          }

        },
        srcSetWebp: {
          type: _graphql.GraphQLString,

          resolve({
            image,
            options
          }) {
            var _image$file5;

            if ((image === null || image === void 0 ? void 0 : (_image$file5 = image.file) === null || _image$file5 === void 0 ? void 0 : _image$file5.contentType) === `image/webp` || options.toFormat === `webp`) {
              return null;
            }

            const fluid = resolveFluid(image, { ...options,
              toFormat: `webp`
            });
            return fluid === null || fluid === void 0 ? void 0 : fluid.srcSet;
          }

        },
        sizes: {
          type: new _graphql.GraphQLNonNull(_graphql.GraphQLString)
        }
      }
    }),
    args: {
      maxWidth: {
        type: _graphql.GraphQLInt
      },
      maxHeight: {
        type: _graphql.GraphQLInt
      },
      quality: {
        type: _graphql.GraphQLInt,
        defaultValue: 50
      },
      toFormat: {
        type: _schemes.ImageFormatType,
        defaultValue: ``
      },
      resizingBehavior: {
        type: _schemes.ImageResizingBehavior
      },
      cropFocus: {
        type: _schemes.ImageCropFocusType,
        defaultValue: null
      },
      cornerRadius: {
        type: _graphql.GraphQLInt,
        defaultValue: 0,
        description: (0, _commonTags.stripIndent)`
         Desired corner radius in pixels. Results in an image with rounded corners.
         Pass \`-1\` for a full circle/ellipse.`
      },
      background: {
        type: _graphql.GraphQLString,
        defaultValue: null
      },
      sizes: {
        type: _graphql.GraphQLString
      }
    },

    resolve(image, options, context) {
      const node = resolveFluid(image, options);
      if (!node) return null;
      return { ...node,
        image,
        options,
        context
      };
    }

  };
};

async function setFieldsOnGraphQLNodeType({
  type,
  cache
}) {
  if (type.name !== `ContentfulAsset`) {
    return {};
  }

  const getTracedSVG = async args => {
    const {
      traceSVG
    } = await Promise.resolve().then(() => _interopRequireWildcard(require(`gatsby-plugin-sharp`)));
    const {
      image,
      options
    } = args;
    const {
      file: {
        contentType,
        url: imgUrl,
        fileName
      }
    } = image;

    if (contentType.indexOf(`image/`) !== 0) {
      return null;
    }

    const extension = mimeTypeExtensions.get(contentType);
    const url = createUrl(imgUrl, options);

    const name = _path.default.basename(fileName, extension);

    const absolutePath = await (0, _gatsbyCoreUtils.fetchRemoteFile)({
      url,
      name,
      cache,
      ext: extension
    });
    return traceSVG({
      file: {
        internal: image.internal,
        name: image.file.fileName,
        extension,
        absolutePath
      },
      args: {
        toFormat: ``
      },
      fileArgs: options
    });
  };

  const getDominantColor = async ({
    image,
    options
  }) => {
    let pluginSharp;

    try {
      pluginSharp = await Promise.resolve().then(() => _interopRequireWildcard(require(`gatsby-plugin-sharp`)));
    } catch (e) {
      console.error(`[gatsby-source-contentful] Please install gatsby-plugin-sharp`, e);
      return `rgba(0,0,0,0.5)`;
    }

    try {
      const {
        file: {
          contentType,
          url: imgUrl,
          fileName
        }
      } = image;

      if (contentType.indexOf(`image/`) !== 0) {
        return null;
      } // 256px should be enough to properly detect the dominant color


      if (!options.width) {
        options.width = 256;
      }

      const extension = mimeTypeExtensions.get(contentType);
      const url = createUrl(imgUrl, options);

      const name = _path.default.basename(fileName, extension);

      const absolutePath = await (0, _gatsbyCoreUtils.fetchRemoteFile)({
        url,
        name,
        cache,
        ext: extension
      });

      if (!(`getDominantColor` in pluginSharp)) {
        console.error(`[gatsby-source-contentful] Please upgrade gatsby-plugin-sharp`);
        return `rgba(0,0,0,0.5)`;
      }

      return pluginSharp.getDominantColor(absolutePath);
    } catch (e) {
      console.error(`[gatsby-source-contentful] Could not getDominantColor from image`, e);
      return `rgba(0,0,0,0.5)`;
    }
  };

  const resolveGatsbyImageData = async (image, options) => {
    if (!isImage(image)) return null;
    const {
      generateImageData
    } = await Promise.resolve().then(() => _interopRequireWildcard(require(`gatsby-plugin-image`)));
    const {
      baseUrl,
      contentType,
      width,
      height
    } = getBasicImageProps(image, options);
    let [, format] = contentType.split(`/`);

    if (format === `jpeg`) {
      format = `jpg`;
    }

    const imageProps = generateImageData({ ...options,
      pluginName: `gatsby-source-contentful`,
      sourceMetadata: {
        width,
        height,
        format
      },
      filename: baseUrl,
      generateImageSource,
      fit: fitMap.get(options.resizingBehavior),
      options
    });
    let placeholderDataURI = null;

    if (options.placeholder === `dominantColor`) {
      imageProps.backgroundColor = await getDominantColor({
        image,
        options
      });
    }

    if (options.placeholder === `blurred`) {
      placeholderDataURI = await getBase64Image({
        baseUrl,
        image,
        options
      }, cache);
    }

    if (options.placeholder === `tracedSVG`) {
      placeholderDataURI = await getTracedSVG({
        image,
        options
      });
    }

    if (placeholderDataURI) {
      imageProps.placeholder = {
        fallback: placeholderDataURI
      };
    }

    return imageProps;
  };

  const fixedNode = fixedNodeType({
    name: `ContentfulFixed`,
    getTracedSVG,
    cache
  });
  const fluidNode = fluidNodeType({
    name: `ContentfulFluid`,
    getTracedSVG,
    cache
  }); // gatsby-plugin-image

  const getGatsbyImageData = async () => {
    const {
      getGatsbyImageFieldConfig
    } = await Promise.resolve().then(() => _interopRequireWildcard(require(`gatsby-plugin-image/graphql-utils`)));
    const fieldConfig = getGatsbyImageFieldConfig(resolveGatsbyImageData, {
      jpegProgressive: {
        type: _graphql.GraphQLBoolean,
        defaultValue: true
      },
      resizingBehavior: {
        type: _schemes.ImageResizingBehavior
      },
      cropFocus: {
        type: _schemes.ImageCropFocusType
      },
      cornerRadius: {
        type: _graphql.GraphQLInt,
        defaultValue: 0,
        description: (0, _commonTags.stripIndent)`
         Desired corner radius in pixels. Results in an image with rounded corners.
         Pass \`-1\` for a full circle/ellipse.`
      },
      quality: {
        type: _graphql.GraphQLInt,
        defaultValue: 50
      },
      layout: {
        type: _schemes.ImageLayoutType,
        description: (0, _commonTags.stripIndent)`
            The layout for the image.
            CONSTRAINED: Resizes to fit its container, up to a maximum width, at which point it will remain fixed in size.
            FIXED: A static image size, that does not resize according to the screen width
            FULL_WIDTH: The image resizes to fit its container, even if that is larger than the source image.
            Pass a value to "sizes" if the container is not the full width of the screen.
        `,
        defaultValue: `constrained`
      },
      placeholder: {
        type: _schemes.ImagePlaceholderType,
        description: (0, _commonTags.stripIndent)`
            Format of generated placeholder image, displayed while the main image loads.
            BLURRED: a blurred, low resolution image, encoded as a base64 data URI (default)
            DOMINANT_COLOR: a solid color, calculated from the dominant color of the image.
            TRACED_SVG: a low-resolution traced SVG of the image.
            NONE: no placeholder. Set the argument "backgroundColor" to use a fixed background color.`,
        defaultValue: `dominantColor`
      },
      formats: {
        type: (0, _graphql.GraphQLList)(_schemes.ImageFormatType),
        description: (0, _commonTags.stripIndent)`
            The image formats to generate. Valid values are AUTO (meaning the same format as the source image), JPG, PNG, and WEBP.
            The default value is [AUTO, WEBP], and you should rarely need to change this. Take care if you specify JPG or PNG when you do
            not know the formats of the source images, as this could lead to unwanted results such as converting JPEGs to PNGs. Specifying
            both PNG and JPG is not supported and will be ignored.
        `,
        defaultValue: [``, `webp`]
      }
    });
    fieldConfig.type = _graphql.GraphQLJSON;
    return fieldConfig;
  };

  const gatsbyImageData = await getGatsbyImageData();
  return {
    fixed: fixedNode,
    fluid: fluidNode,
    gatsbyImageData,
    resize: {
      type: new _graphql.GraphQLObjectType({
        name: `ContentfulResize`,
        fields: {
          base64: {
            type: _graphql.GraphQLString,
            resolve: imageProps => getBase64Image(imageProps, cache)
          },
          tracedSVG: {
            type: _graphql.GraphQLString,
            resolve: getTracedSVG
          },
          src: {
            type: _graphql.GraphQLString
          },
          width: {
            type: _graphql.GraphQLInt
          },
          height: {
            type: _graphql.GraphQLInt
          },
          aspectRatio: {
            type: _graphql.GraphQLFloat
          }
        }
      }),
      args: {
        width: {
          type: _graphql.GraphQLInt
        },
        height: {
          type: _graphql.GraphQLInt
        },
        quality: {
          type: _graphql.GraphQLInt,
          defaultValue: 50
        },
        jpegProgressive: {
          type: _graphql.GraphQLBoolean,
          defaultValue: true
        },
        resizingBehavior: {
          type: _schemes.ImageResizingBehavior
        },
        toFormat: {
          type: _schemes.ImageFormatType,
          defaultValue: ``
        },
        cropFocus: {
          type: _schemes.ImageCropFocusType,
          defaultValue: null
        },
        background: {
          type: _graphql.GraphQLString,
          defaultValue: null
        },
        cornerRadius: {
          type: _graphql.GraphQLInt,
          defaultValue: 0,
          description: (0, _commonTags.stripIndent)`
         Desired corner radius in pixels. Results in an image with rounded corners.
         Pass \`-1\` for a full circle/ellipse.`
        }
      },

      resolve(image, options) {
        return resolveResize(image, options);
      }

    }
  };
}